@page "/"
@page "/compiler"
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp
@using Microsoft.CodeAnalysis.Emit
@using System.IO
@using System.Reflection
@using System.Text
@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime

<PageTitle>C# WebAssembly Compiler</PageTitle>

<div class="compiler-container">
    <!-- Header with title and compile button -->
    <div class="header">
        <h1>C# WebAssembly Compiler</h1>
        <button class="btn btn-primary compile-btn" @onclick="CompileAndRun" disabled="@isCompiling">
            @if (isCompiling)
            {
                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                <span>Compiling...</span>
            }
            else
            {
                <span>Compile & Run</span>
            }
        </button>
    </div>

    <!-- Code Editor Section -->
    <div class="editor-section">
        <div class="section-header">
            <span>üìù C# Code Editor</span>
        </div>
        <div class="editor-container">
            <textarea @bind="sourceCode" @bind:event="oninput" class="code-editor" 
                      placeholder="Write your C# code here..." spellcheck="false"></textarea>
        </div>
    </div>

    <!-- Output Console Section -->
    <div class="output-section">
        <div class="section-header">
            <span>üì∫ Output Console</span>
            <button class="btn btn-outline-secondary btn-sm" @onclick="ClearOutput">Clear</button>
        </div>
        <div class="output-container">
            <div class="output-content" id="output">
                @((MarkupString)output)
            </div>
        </div>
    </div>
</div>

<style>
    .compiler-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        max-height: 100vh;
        overflow: hidden;
    }

    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .header h1 {
        margin: 0;
        font-size: 1.8rem;
        font-weight: 600;
    }

    .compile-btn {
        padding: 0.6rem 1.2rem;
        font-size: 1rem;
        font-weight: 500;
        border: none;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
    }

    .compile-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-1px);
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .compile-btn:disabled {
        opacity: 0.7;
        cursor: not-allowed;
    }

    .editor-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        border-bottom: 2px solid #e9ecef;
    }

    .output-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
    }

    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.8rem 1.5rem;
        background-color: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        font-weight: 600;
        color: #495057;
    }

    .editor-container {
        flex: 1;
        position: relative;
        min-height: 0;
    }

    .code-editor {
        width: 100%;
        height: 100%;
        border: none;
        outline: none;
        resize: none;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
        padding: 1rem;
        background-color: #1e1e1e;
        color: #d4d4d4;
        tab-size: 4;
    }

    .code-editor::placeholder {
        color: #6a6a6a;
        font-style: italic;
    }

    .output-container {
        flex: 1;
        position: relative;
        min-height: 0;
    }

    .output-content {
        width: 100%;
        height: 100%;
        overflow-y: auto;
        padding: 1rem;
        background-color: #0d1117;
        color: #f0f6fc;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.4;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .btn-sm {
        font-size: 0.8rem;
        padding: 0.4rem 0.8rem;
    }

    /* Responsive design */
    @@media (max-width: 768px) {
        .header {
            flex-direction: column;
            gap: 1rem;
            text-align: center;
        }
        
        .header h1 {
            font-size: 1.5rem;
        }
        
        .section-header {
            padding: 0.6rem 1rem;
            font-size: 0.9rem;
        }
        
        .code-editor, .output-content {
            padding: 0.8rem;
            font-size: 13px;
        }
    }

    /* Output styling */
    .success { color: #28a745; }
    .error { color: #dc3545; }
    .warning { color: #ffc107; }
    .info { color: #17a2b8; }
</style>

@code {
    private string sourceCode = @"using System;

public class Program
{
    public static void Main()
    {
        Console.WriteLine(""Hello from C# WebAssembly!"");
        Console.WriteLine(""This code runs real C# compilation and execution in your browser."");
        Console.WriteLine();
        
        // Basic variables
        string language = ""C#"";
        int year = 2025;
        bool isAwesome = true;
        
        Console.WriteLine($""Language: {language}"");
        Console.WriteLine($""Year: {year}"");
        Console.WriteLine($""Is awesome: {isAwesome}"");
        Console.WriteLine();
        
        // Simple loop
        Console.WriteLine(""Counting to 5:"");
        for (int i = 1; i <= 5; i++)
        {
            Console.WriteLine($""Count: {i}"");
        }
        
        Console.WriteLine();
        Console.WriteLine(""C# compilation successful!"");
    }
}";

    private string output = @"<span class='info'>Real Blazor WebAssembly C# Compiler Ready!</span><br/>
<span class='info'>This environment provides:</span><br/>
<span class='success'>‚úì Real Roslyn C# compilation in WebAssembly</span><br/>
<span class='success'>‚úì Authentic .NET runtime execution</span><br/>
<span class='success'>‚úì Full C# language support</span><br/>
<span class='success'>‚úì True compilation error reporting</span><br/>
<span class='success'>‚úì All dependencies packaged as .wasm files</span><br/><br/>
<span class='info'>Click 'Compile & Run' to execute your C# code!</span><br/>
";
    private bool isCompiling = false;

    private async Task CompileAndRun()
    {
        isCompiling = true;
        AddOutput("Compiling C# code with real Roslyn compiler...", "info");
        StateHasChanged();

        try
        {
            var result = await CompileCSharpCode(sourceCode);
            
            if (result.Success)
            {
                AddOutput("Roslyn compilation successful!", "success");
                AddOutput("Executing compiled assembly in .NET WebAssembly...", "info");
                AddOutput("--- Program Output ---", "info");
                
                var executionResult = await ExecuteAssembly(result.Assembly!);
                AddOutput(executionResult, "");
                AddOutput("--- End of Output ---", "info");
                AddOutput(".NET WebAssembly execution completed successfully!", "success");
            }
            else
            {
                AddOutput("Compilation failed with Roslyn:", "error");
                foreach (var error in result.Errors)
                {
                    var lineNumber = error.Location.GetLineSpan().StartLinePosition.Line + 1;
                    AddOutput($"Line {lineNumber}: {error.GetMessage()}", "error");
                }
            }
        }
        catch (Exception ex)
        {
            AddOutput($"Error: {ex.Message}", "error");
        }
        finally
        {
            isCompiling = false;
            StateHasChanged();
        }
    }

    private void AddOutput(string text, string cssClass)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss");
        var line = $"<span class='{cssClass}'>[{timestamp}] {text.Replace("\n", "<br/>")}</span><br/>";
        output += line;
    }

    private void ClearOutput()
    {
        output = "";
    }

    private Task<CompilationResult> CompileCSharpCode(string code)
    {
        try
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(code);
            
            // For WebAssembly, we need to manually build essential references
            var references = new List<MetadataReference>();
            
            AddOutput("Attempting to load references for WebAssembly environment...", "info");
            
            // Method 1: Try Basic.Reference.Assemblies.Net90 with deep API exploration
            try
            {
                var net90Type = typeof(Basic.Reference.Assemblies.Net90);
                AddOutput($"Basic.Reference.Assemblies.Net90 type loaded: {net90Type.FullName}", "info");
                
                // Access the References nested type
                var referencesType = net90Type.GetNestedType("References");
                if (referencesType != null)
                {
                    AddOutput($"Found References nested type: {referencesType.FullName}", "success");
                    
                    // Get ALL members to understand the API structure
                    var allMembers = referencesType.GetMembers(BindingFlags.Public | BindingFlags.Static);
                    AddOutput($"References type has {allMembers.Length} members", "info");
                    
                    // Show all member types and names
                    foreach (var member in allMembers.Take(20))
                    {
                        AddOutput($"  {member.MemberType}: {member.Name} -> {member}", "info");
                    }
                    
                    // Try different approaches to get references
                    // Approach 1: Look for MetadataReference properties
                    var refProperties = referencesType.GetProperties(BindingFlags.Public | BindingFlags.Static)
                        .Where(p => p.PropertyType == typeof(MetadataReference))
                        .ToArray();
                    AddOutput($"Found {refProperties.Length} MetadataReference properties", "info");
                    
                    // Approach 2: Look for IEnumerable<MetadataReference> properties
                    var enumProperties = referencesType.GetProperties(BindingFlags.Public | BindingFlags.Static)
                        .Where(p => typeof(IEnumerable<MetadataReference>).IsAssignableFrom(p.PropertyType))
                        .ToArray();
                    AddOutput($"Found {enumProperties.Length} IEnumerable<MetadataReference> properties", "info");
                    
                    // Approach 3: Look for methods that return MetadataReference or collections
                    var refMethods = referencesType.GetMethods(BindingFlags.Public | BindingFlags.Static)
                        .Where(m => m.ReturnType == typeof(MetadataReference) || 
                                   typeof(IEnumerable<MetadataReference>).IsAssignableFrom(m.ReturnType))
                        .ToArray();
                    AddOutput($"Found {refMethods.Length} methods returning MetadataReference(s)", "info");
                    
                    // Try the enumerable properties first
                    foreach (var prop in enumProperties)
                    {
                        try
                        {
                            var refs = (IEnumerable<MetadataReference>?)prop.GetValue(null);
                            if (refs != null)
                            {
                                var refsArray = refs.ToArray();
                                references.AddRange(refsArray);
                                AddOutput($"Successfully loaded {refsArray.Length} references from {prop.Name}", "success");
                            }
                        }
                        catch (Exception ex)
                        {
                            AddOutput($"Error loading from {prop.Name}: {ex.Message}", "error");
                        }
                    }
                    
                    // Try individual MetadataReference properties
                    foreach (var prop in refProperties)
                    {
                        try
                        {
                            var reference = (MetadataReference?)prop.GetValue(null);
                            if (reference != null)
                            {
                                references.Add(reference);
                                AddOutput($"Successfully loaded: {prop.Name}", "success");
                            }
                        }
                        catch (Exception ex)
                        {
                            AddOutput($"Error loading {prop.Name}: {ex.Message}", "error");
                        }
                    }
                }
                else
                {
                    AddOutput("References nested type not found", "error");
                }
                
                AddOutput($"Total references loaded: {references.Count}", references.Count > 0 ? "success" : "warning");
            }
            catch (Exception ex)
            {
                AddOutput($"Basic.Reference.Assemblies.Net90 failed: {ex.Message}", "error");
                AddOutput($"Exception details: {ex.GetType().Name}", "error");
            }
            
            // Method 2: If no references loaded, show what we're working with
            if (references.Count == 0)
            {
                AddOutput("No references loaded from Basic.Reference.Assemblies", "warning");
                AddOutput("Proceeding with compilation to see specific errors...", "info");
                
                // List the assemblies we have available
                var loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
                AddOutput($"Available assemblies in current domain: {loadedAssemblies.Length}", "info");
                
                foreach (var asm in loadedAssemblies.Take(10))
                {
                    var name = asm.GetName().Name ?? "Unknown";
                    var location = string.IsNullOrEmpty(asm.Location) ? "No location" : asm.Location;
                    AddOutput($"  {name} -> {location}", "info");
                }
            }

            // Attempt compilation with whatever references we have
            var compilation = CSharpCompilation.Create(
                "DynamicAssembly",
                new[] { syntaxTree },
                references,
                new CSharpCompilationOptions(OutputKind.ConsoleApplication));

            using var ms = new MemoryStream();
            var emitResult = compilation.Emit(ms);

            if (emitResult.Success)
            {
                AddOutput("Compilation succeeded!", "success");
                ms.Seek(0, SeekOrigin.Begin);
                var assembly = Assembly.Load(ms.ToArray());
                return Task.FromResult(new CompilationResult { Success = true, Assembly = assembly });
            }
            else
            {
                var errors = emitResult.Diagnostics
                    .Where(d => d.Severity == DiagnosticSeverity.Error)
                    .ToList();
                
                AddOutput($"Compilation failed with {errors.Count} errors", "error");
                
                // Group similar errors and show summary
                var errorGroups = errors.GroupBy(e => e.Id).ToArray();
                AddOutput("Error summary:", "error");
                
                foreach (var group in errorGroups.Take(5)) // Show top 5 error types
                {
                    var firstError = group.First();
                    var count = group.Count();
                    AddOutput($"  {group.Key}: {firstError.GetMessage()} ({count} occurrences)", "error");
                }
                
                if (errorGroups.Length > 5)
                {
                    AddOutput($"  ... and {errorGroups.Length - 5} other error types", "error");
                }
                
                return Task.FromResult(new CompilationResult 
                { 
                    Success = false, 
                    Errors = errors
                });
            }
        }
        catch (Exception ex)
        {
            AddOutput($"Compilation exception: {ex.Message}", "error");
            AddOutput($"Exception type: {ex.GetType().Name}", "error");
            if (ex.InnerException != null)
            {
                AddOutput($"Inner exception: {ex.InnerException.Message}", "error");
            }
            
            return Task.FromResult(new CompilationResult 
            { 
                Success = false, 
                Errors = new List<Diagnostic>()
            });
        }
    }

    private byte[]? GetAssemblyBytes(Assembly assembly)
    {
        try
        {
            // In WebAssembly, we need to extract assembly bytes differently
            // Try multiple approaches to get the assembly data
            
            // Method 1: Try to use the location if available
            if (!string.IsNullOrEmpty(assembly.Location))
            {
                return File.ReadAllBytes(assembly.Location);
            }
            
            // Method 2: Try to get from memory (this might work in some WebAssembly scenarios)
            return null;
        }
        catch (Exception ex)
        {
            AddOutput($"GetAssemblyBytes error for {assembly.GetName().Name}: {ex.Message}", "error");
            return null;
        }
    }

    private Task<string> ExecuteAssembly(Assembly assembly)
    {
        var output = new StringBuilder();
        var originalOut = Console.Out;
        
        try
        {
            using var stringWriter = new StringWriter(output);
            Console.SetOut(stringWriter);
            
            // Find and execute the Main method with proper parameter handling
            var entryPoint = assembly.EntryPoint;
            if (entryPoint != null)
            {
                // Check the parameter signature of the entry point
                var parameters = entryPoint.GetParameters();
                if (parameters.Length == 0)
                {
                    // Main() with no parameters
                    entryPoint.Invoke(null, null);
                }
                else if (parameters.Length == 1 && parameters[0].ParameterType == typeof(string[]))
                {
                    // Main(string[] args) 
                    entryPoint.Invoke(null, new object[] { new string[0] });
                }
                else
                {
                    AddOutput($"Unsupported Main method signature: {entryPoint}", "error");
                    return Task.FromResult("Error: Unsupported Main method signature");
                }
            }
            else
            {
                // Fallback: Look for Program.Main method manually
                var programType = assembly.GetType("Program");
                if (programType != null)
                {
                    // Try Main() first
                    var mainMethod = programType.GetMethod("Main", BindingFlags.Static | BindingFlags.Public, null, Type.EmptyTypes, null);
                    if (mainMethod != null)
                    {
                        mainMethod.Invoke(null, null);
                    }
                    else
                    {
                        // Try Main(string[])
                        mainMethod = programType.GetMethod("Main", BindingFlags.Static | BindingFlags.Public, null, new[] { typeof(string[]) }, null);
                        if (mainMethod != null)
                        {
                            mainMethod.Invoke(null, new object[] { new string[0] });
                        }
                        else
                        {
                            return Task.FromResult("Error: No suitable Main method found");
                        }
                    }
                }
                else
                {
                    return Task.FromResult("Error: No Program class found");
                }
            }
        }
        catch (TargetInvocationException ex)
        {
            // Unwrap the inner exception to get the real error
            var innerEx = ex.InnerException ?? ex;
            AddOutput($"Execution error (inner): {innerEx.GetType().Name}: {innerEx.Message}", "error");
            if (innerEx.StackTrace != null)
            {
                AddOutput($"Stack trace: {innerEx.StackTrace}", "error");
            }
            return Task.FromResult($"Execution error: {innerEx.Message}");
        }
        catch (Exception ex)
        {
            AddOutput($"Execution error: {ex.GetType().Name}: {ex.Message}", "error");
            if (ex.StackTrace != null)
            {
                AddOutput($"Stack trace: {ex.StackTrace}", "error");
            }
            return Task.FromResult($"Execution error: {ex.Message}");
        }
        finally
        {
            Console.SetOut(originalOut);
        }
        
        return Task.FromResult(output.ToString());
    }

    private class CompilationResult
    {
        public bool Success { get; set; }
        public Assembly? Assembly { get; set; }
        public List<Diagnostic> Errors { get; set; } = new();
    }
}