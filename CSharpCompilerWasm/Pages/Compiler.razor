@page "/"
@page "/compiler"
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp
@using Microsoft.CodeAnalysis.Emit
@using System.IO
@using System.Reflection
@using System.Text
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JSRuntime

<PageTitle>C# minor</PageTitle>

<script>
    window.scrollToBottom = (elementId) => {
        const element = document.getElementById(elementId);
        if (element) {
            element.scrollTop = element.scrollHeight;
        }
    };

    window.promptForInput = async (promptText) => {
        return new Promise((resolve) => {
            // Create input UI in the console
            const outputElement = document.getElementById('output');
            if (outputElement) {
                // Create a container for the input line
                const inputContainer = document.createElement('div');
                inputContainer.style.display = 'flex';
                inputContainer.style.alignItems = 'center';
                inputContainer.style.width = '100%';
                
                // Add the prompt text
                const promptDiv = document.createElement('span');
                promptDiv.innerHTML = promptText;
                promptDiv.style.color = '#17a2b8';
                inputContainer.appendChild(promptDiv);
                
                // Add the ">" indicator
                const promptIndicator = document.createElement('span');
                promptIndicator.textContent = '>';
                promptIndicator.style.color = '#f0f6fc';
                promptIndicator.style.marginLeft = '5px';
                promptIndicator.style.marginRight = '5px';
                promptIndicator.style.fontFamily = "'Consolas', 'Monaco', 'Courier New', monospace";
                promptIndicator.style.fontSize = '13px';
                promptIndicator.style.fontWeight = 'bold';
                inputContainer.appendChild(promptIndicator);
                
                // Create input field
                const inputField = document.createElement('input');
                inputField.type = 'text';
                inputField.style.backgroundColor = '#0d1117';
                inputField.style.color = '#f0f6fc';
                inputField.style.border = 'none';
                inputField.style.padding = '0';
                inputField.style.fontFamily = "'Consolas', 'Monaco', 'Courier New', monospace";
                inputField.style.fontSize = '13px';
                inputField.style.outline = 'none';
                inputField.style.width = '100%';
                inputField.style.flex = '1';
                
                // Handle input submission
                inputField.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const value = inputField.value;
                        
                        // Replace input field with the entered value
                        const valueSpan = document.createElement('span');
                        valueSpan.textContent = value;
                        valueSpan.style.color = '#f0f6fc';
                        inputField.parentNode.replaceChild(valueSpan, inputField);
                        
                        // Add the container to output and then add line break
                        outputElement.appendChild(inputContainer);
                        const br = document.createElement('br');
                        outputElement.appendChild(br);
                        
                        // Scroll to bottom
                        window.scrollToBottom('output');
                        
                        resolve(value);
                    }
                });
                
                // Add input field to container
                inputContainer.appendChild(inputField);
                
                // Add container to output
                outputElement.appendChild(inputContainer);
                
                // Focus the input field and scroll to bottom
                inputField.focus();
                window.scrollToBottom('output');
            } else {
                // Fallback to browser prompt
                resolve(prompt(promptText) || '');
            }
        });
    };
</script>

<!-- Skip link for keyboard navigation -->
<a href="#code-editor" class="skip-link">Skip to code editor</a>

<div class="compiler-container" role="application" aria-label="C# Code Editor Application">
    <!-- Header with title -->
    <header class="header" role="banner">
        <div class="header-content">
            <h1 id="main-title">C# minor</h1>
            <p class="subheading" aria-describedby="main-title">A C# code editor for educational use</p>
        </div>
    </header>

    <!-- Code Editor Section -->
    <section class="editor-section" role="main" aria-labelledby="editor-heading">
        <div class="section-header">
            <h3 id="editor-heading">üìù C# Code Editor</h3>
            <div class="editor-controls" role="toolbar" aria-label="Editor controls">
                <button class="btn btn-outline-secondary btn-sm" 
                        @onclick="LoadSampleCode" 
                        @onkeydown="@(async (e) => await HandleKeyDown(e, LoadSampleCode))"
                        title="Load sample code"
                        aria-label="Load sample C# code example"
                        aria-describedby="sample-code-desc">
                    <span aria-hidden="true">üìÑ</span> Sample
                </button>
                <div id="sample-code-desc" class="sr-only">Loads a comprehensive C# code example with variables, loops, and console output</div>
                <div class="toggle-container">
                    <label class="toggle-switch" 
                           aria-label="Toggle between simplified and full code view"
                           aria-describedby="code-view-desc"
                           title="Toggle between simplified and full code view">
                        <input type="checkbox" 
                               checked="@showFullCode" 
                               @onchange="OnToggleChanged"
                               @onkeydown="@(async (e) => await HandleToggleKeyDown(e, OnToggleChanged))"
                               aria-describedby="code-view-desc"
                               role="switch"
                               aria-checked="@showFullCode" />
                        <span class="toggle-slider" aria-hidden="true"></span>
                        <span class="toggle-label" aria-hidden="true">{..}</span>
                    </label>
                    <div id="code-view-desc" class="sr-only">
                        @if (showFullCode)
                        {
                            <text>Currently showing full code with using statements and class structure. Toggle to show simplified code view.</text>
                        }
                        else
                        {
                            <text>Currently showing simplified code view with just the main method content. Toggle to show full code structure.</text>
                        }
                    </div>
                </div>
            </div>
        </div>
        <div class="editor-container">
            <label for="code-editor" class="sr-only">C# Code Editor</label>
            <textarea id="code-editor"
                      @bind="displayCode" 
                      @bind:event="oninput" 
                      @onkeydown="HandleEditorKeyDown"
                      class="code-editor" 
                      placeholder="Write your C# code here..."
                      spellcheck="false"
                      aria-label="C# code editor"
                      aria-describedby="editor-instructions"
                      role="textbox"
                      aria-multiline="true"
                      rows="15"></textarea>
            <div id="editor-instructions" class="sr-only">
                Type your C# code here. Press Ctrl+Enter to compile and run. Use the Sample button to load example code.
            </div>
        </div>
    </section>

    <!-- Compile Button Section -->
    <section class="compile-section" role="region" aria-labelledby="compile-heading">
        <h3 id="compile-heading" class="sr-only">Compile and Run</h3>
        <button class="btn btn-primary compile-btn" 
                @onclick="CompileAndRun" 
                @onkeydown="@(async (e) => await HandleKeyDown(e, CompileAndRun))"
                disabled="@isCompiling" 
                aria-label="@GetCompileButtonLabel()"
                aria-describedby="compile-instructions"
                aria-live="polite"
                title="Compile and run your C# code">
            @if (isCompiling)
            {
                <span class="spinner-border spinner-border-sm" role="status" aria-label="Compiling..."></span>
            }
            else
            {
                <span aria-hidden="true">&#9654;</span>
            }
        </button>
        <div id="compile-instructions" class="sr-only">
            Compiles your C# code using the Roslyn compiler and executes it in WebAssembly. Keyboard shortcut: Ctrl+Enter from the code editor.
        </div>
    </section>


    <!-- Output Console Section -->
    <section class="output-section" role="region" aria-labelledby="output-heading" aria-live="polite">
        <div class="section-header">
            <h3 id="output-heading">&#128468; Output Console</h3>
            <div class="console-controls" role="toolbar" aria-label="Console controls">
                <div class="toggle-container">
                    <label class="toggle-switch" 
                           aria-label="Toggle system output visibility"
                           aria-describedby="system-output-desc"
                           title="Toggle system output visibility">
                        <input type="checkbox" 
                               checked="@showSystemOutput" 
                               @onchange="OnSystemOutputToggleChanged"
                               @onkeydown="@(async (e) => await HandleToggleKeyDown(e, OnSystemOutputToggleChanged))"
                               role="switch"
                               aria-checked="@showSystemOutput"
                               aria-describedby="system-output-desc" />
                        <span class="toggle-slider" aria-hidden="true"></span>
                        <span class="toggle-label" aria-hidden="true">[*]</span>
                    </label>
                    <div id="system-output-desc" class="sr-only">
                        @if (showSystemOutput)
                        {
                            <text>System output is visible. Shows compilation messages, timestamps, and debug information along with your program output.</text>
                        }
                        else
                        {
                            <text>System output is hidden. Shows only your program's console output for a cleaner view.</text>
                        }
                    </div>
                </div>
                <button class="btn btn-outline-secondary btn-sm" 
                        @onclick="ClearOutput"
                        @onkeydown="@(async (e) => await HandleKeyDown(e, ClearOutput))"
                        aria-label="Clear console output"
                        aria-describedby="clear-instructions">
                    Clear
                </button>
                <div id="clear-instructions" class="sr-only">Clears all output from the console</div>
            </div>
        </div>
        <div class="output-container">
            <div class="output-content" 
                 id="output" 
                 role="log" 
                 aria-label="Program output"
                 aria-describedby="output-instructions"
                 aria-live="polite"
                 tabindex="0">
                @((MarkupString)GetDisplayOutput())
            </div>
            <div id="output-instructions" class="sr-only">
                This area displays the results of your compiled C# program. Use the system output toggle to show or hide compilation details.
            </div>
        </div>
    </section>
</div>

<style>
    .compiler-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        max-height: 100vh;
        overflow: hidden;
    }

    .header {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 1rem 1.5rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .header-content {
        text-align: center;
    }

    .header h1 {
        margin: 0 0 0.25rem 0;
        font-size: 1.8rem;
        font-weight: 600;
    }

    .subheading {
        margin: 0;
        font-size: 0.9rem;
        font-weight: 400;
        opacity: 0.9;
        font-style: italic;
    }

    .compile-section {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        padding: 1rem 1.5rem;
        background-color: #f8f9fa;
        border-bottom: 2px solid #e9ecef;
    }

    .compile-btn {
        padding: 0.8rem;
        font-size: 1.2rem;
        font-weight: 600;
        border: none;
        border-radius: 8px;
        background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
        color: white;
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
        transition: all 0.3s ease;
        cursor: pointer;
        width: 3rem;
        height: 3rem;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .compile-btn:hover:not(:disabled) {
        background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 123, 255, 0.4);
    }

    .compile-btn:disabled {
        opacity: 0.7;
        cursor: not-allowed;
        transform: none;
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
    }

    .editor-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        border-bottom: 2px solid #e9ecef;
    }

    .output-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
    }

    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.8rem 1.5rem;
        background-color: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        font-weight: 600;
        color: #495057;
    }

    .section-header h3 {
        font-size: 1.1rem;
        margin: 0;
        font-weight: 600;
    }

    .toggle-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .console-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
    }

    .editor-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
    }

    /* Screen reader only content */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }

    /* Focus indicators for accessibility */
    .code-editor:focus,
    .compile-btn:focus,
    .btn:focus,
    .toggle-switch input:focus + .toggle-slider {
        outline: 3px solid #007bff;
        outline-offset: 2px;
    }

    .toggle-switch {
        position: relative;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        user-select: none;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: relative;
        width: 44px;
        height: 24px;
        background-color: #ccc;
        border-radius: 24px;
        transition: 0.3s;
    }

    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        border-radius: 50%;
        transition: 0.3s;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .toggle-switch input:checked + .toggle-slider {
        background-color: #667eea;
    }

    .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(20px);
    }

    .toggle-label {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 12px;
        font-weight: bold;
        color: #666;
    }

    .editor-container {
        flex: 1;
        position: relative;
        min-height: 0;
    }

    .code-editor {
        width: 100%;
        height: 100%;
        border: none;
        outline: none;
        resize: none;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
        padding: 1rem;
        background-color: #1e1e1e;
        color: #d4d4d4;
        tab-size: 4;
    }

    .code-editor::placeholder {
        color: #6a6a6a;
        font-style: italic;
    }

    .output-container {
        flex: 1;
        position: relative;
        min-height: 0;
    }

    .output-content {
        width: 100%;
        height: 100%;
        overflow-y: auto;
        padding: 1rem;
        background-color: #0d1117;
        color: #f0f6fc;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.4;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .btn-sm {
        font-size: 0.8rem;
        padding: 0.4rem 0.8rem;
    }

    /* Output styling */
    .success { color: #28a745; }
    .error { color: #dc3545; }
    .warning { color: #ffc107; }
    .info { color: #17a2b8; }

    /* Skip link for keyboard navigation */
    .skip-link {
        position: absolute;
        top: -40px;
        left: 6px;
        background: #007bff;
        color: white;
        padding: 8px;
        text-decoration: none;
        border-radius: 0 0 4px 4px;
        z-index: 1000;
    }

    .skip-link:focus {
        top: 0;
    }

    /* Responsive design */
    @@media (max-width: 768px) {
        .header {
            flex-direction: column;
            gap: 1rem;
            text-align: center;
        }
        
        .header h1 {
            font-size: 1.5rem;
        }
        
        .section-header {
            padding: 0.6rem 1rem;
            font-size: 0.9rem;
        }
        
        .code-editor, .output-content {
            padding: 0.8rem;
            font-size: 13px;
        }
    }

    /* High contrast mode support */
    @@media (prefers-contrast: high) {
        .header {
            background: #000;
            color: #fff;
            border-bottom: 2px solid #fff;
        }
        
        .section-header {
            background-color: #f0f0f0;
            border: 1px solid #000;
        }
        
        .code-editor {
            border: 2px solid #000;
            background: #fff;
            color: #000;
        }
        
        .output-content {
            border: 2px solid #000;
            background: #fff;
        }
    }

    /* Reduced motion support */
    @@media (prefers-reduced-motion: reduce) {
        .compile-btn,
        .toggle-slider,
        * {
            transition: none !important;
            animation: none !important;
        }
    }
</style>

@code {
    private string sourceCode = @"using System;

public class Program
{
    public static void Main()
    {
    }
}";

    private string sampleCode = @"using System;

public class Program
{
    public static void Main()
    {
        Console.WriteLine(""Hello from C# WebAssembly!"");
        Console.WriteLine(""This code runs real C# compilation and execution in your browser."");
        Console.WriteLine();
        
        // Interactive input example
        Console.Write(""What is your name? "");
        string name = Console.ReadLine();
        Console.WriteLine($""Hello, {name}! Nice to meet you."");
        Console.WriteLine();
        
        // Basic variables
        string language = ""C#"";
        int year = 2025;
        bool isAwesome = true;
        char grade = 'A';
        
        Console.WriteLine($""Language: {language}"");
        Console.WriteLine($""Year: {year}"");
        Console.WriteLine($""Is awesome: {isAwesome}"");
        Console.WriteLine($""Grade: {grade}"");
        Console.WriteLine();
        
        // Another interactive example
        Console.Write(""Enter a number: "");
        string numberInput = Console.ReadLine();
        if (int.TryParse(numberInput, out int number))
        {
            Console.WriteLine($""You entered: {number}"");
            Console.WriteLine($""Double that number is: {number * 2}"");
        }
        else
        {
            Console.WriteLine(""That wasn't a valid number!"");
        }
        Console.WriteLine();
        
        // Simple loop
        Console.WriteLine(""Counting to 5:"");
        for (int i = 1; i <= 5; i++)
        {
            Console.WriteLine($""Count: {i}"");
        }
        
        Console.WriteLine();
        Console.WriteLine(""C# compilation successful!"");
    }
}";

    private string output = @"<span class='info'>Real Blazor WebAssembly C# Compiler Ready!</span><br/>
<span class='info'>This environment provides:</span><br/>
<span class='success'>‚úì Real Roslyn C# compilation in WebAssembly</span><br/>
<span class='success'>‚úì Authentic .NET runtime execution</span><br/>
<span class='success'>‚úì Full C# language support</span><br/>
<span class='success'>‚úì True compilation error reporting</span><br/>
<span class='success'>‚úì All dependencies packaged as .wasm files</span><br/>
<span class='success'>‚úì Real Console.ReadLine() interactive input</span><br/><br/>
<span class='info'>Click 'Compile & Run' to execute your C# code!</span><br/>
";
    private string systemOutput = @"<span class='info'>Real Blazor WebAssembly C# Compiler Ready!</span><br/>
<span class='info'>This environment provides:</span><br/>
<span class='success'>‚úì Real Roslyn C# compilation in WebAssembly</span><br/>
<span class='success'>‚úì Authentic .NET runtime execution</span><br/>
<span class='success'>‚úì Full C# language support</span><br/>
<span class='success'>‚úì True compilation error reporting</span><br/>
<span class='success'>‚úì All dependencies packaged as .wasm files</span><br/>
<span class='success'>‚úì Real Console.ReadLine() interactive input</span><br/><br/>
<span class='info'>Click 'Compile & Run' to execute your C# code!</span><br/>
";
    private string userOutput = "";
    private string errorOutput = "";
    private bool isCompiling = false;
    private bool showFullCode = false;
    private bool showSystemOutput = false;
    private string displayCode = "";

    private async Task CompileAndRun()
    {
        isCompiling = true;
        AddOutput("Compiling C# code with real Roslyn compiler...", "info");
        StateHasChanged();
        await ScrollToBottom();

        try
        {
            // Ensure we have the current full source code
            if (!showFullCode)
            {
                // If we're in simplified mode, update the source code from displayCode
                OnCodeChanged(new ChangeEventArgs { Value = displayCode });
            }
            
            var result = await CompileCSharpCode(sourceCode);
            
            if (result.Success)
            {
                AddOutput("Roslyn compilation successful!", "success");
                StateHasChanged();
                await ScrollToBottom();
                
                AddOutput("Executing compiled assembly in .NET WebAssembly...", "info");
                StateHasChanged();
                await ScrollToBottom();
                
                AddOutput("--- Program Output ---", "info");
                StateHasChanged();
                await ScrollToBottom();
                
                var executionResult = await ExecuteAssembly(result.Assembly!);
                AddUserOutput(executionResult);
                StateHasChanged();
                await ScrollToBottom();
                
                AddOutput("--- End of Output ---", "info");
                AddOutput(".NET WebAssembly execution completed successfully!", "success");
                StateHasChanged();
                await ScrollToBottom();
            }
            else
            {
                AddErrorOutput("Compilation failed with Roslyn:", "error");
                StateHasChanged();
                await ScrollToBottom();
                
                foreach (var error in result.Errors)
                {
                    var lineNumber = error.Location.GetLineSpan().StartLinePosition.Line + 1;
                    AddErrorOutput($"Line {lineNumber}: {error.GetMessage()}", "error");
                }
                StateHasChanged();
                await ScrollToBottom();
            }
        }
        catch (Exception ex)
        {
            AddErrorOutput($"Error: {ex.Message}", "error");
            StateHasChanged();
            await ScrollToBottom();
        }
        finally
        {
            isCompiling = false;
            StateHasChanged();
        }
    }

    private void AddOutput(string text, string cssClass)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss");
        var line = $"<span class='{cssClass}'>[{timestamp}] {text.Replace("\n", "<br/>")}</span><br/>";
        output += line; // Append to bottom
        systemOutput += line; // Append to bottom
    }

    private void AddUserOutput(string text)
    {
        var line = text.Replace("\n", "<br/>");
        if (!string.IsNullOrEmpty(line))
        {
            var formattedLine = line + "<br/>";
            userOutput += formattedLine; // Append to bottom
            output += formattedLine; // Append to bottom
        }
    }

    private void AddErrorOutput(string text, string cssClass)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss");
        var line = $"<span class='{cssClass}'>[{timestamp}] {text.Replace("\n", "<br/>")}</span><br/>";
        errorOutput += line; // Append to bottom
        userOutput += line; // Append to bottom to maintain chronological order
        output += line; // Append to bottom
    }

    private string GetDisplayOutput()
    {
        if (showSystemOutput)
        {
            return output;
        }
        else
        {
            // When system output is hidden, show only user output (which includes errors in chronological order)
            return string.IsNullOrEmpty(userOutput) ? "" : userOutput;
        }
    }

    private void OnSystemOutputToggleChanged(ChangeEventArgs e)
    {
        showSystemOutput = e.Value as bool? ?? false;
        StateHasChanged();
        _ = ScrollToBottom(); // Fire and forget
    }

    private void ClearOutput()
    {
        output = "";
        systemOutput = "";
        userOutput = "";
        errorOutput = "";
        StateHasChanged();
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", "output");
        }
        catch (Exception)
        {
            // Ignore JavaScript errors (e.g., during prerendering)
        }
    }

    private void OnCodeChanged(ChangeEventArgs e)
    {
        var newCode = e.Value?.ToString() ?? "";
        
        if (showFullCode)
        {
            // When in full code mode, update the full source code
            sourceCode = newCode;
        }
        else
        {
            // When in simple mode, update only the main method content
            // Add proper indentation to each line for the Main method
            var indentedCode = IndentCode(newCode, "        "); // 8 spaces for Main method content
            sourceCode = @"using System;

public class Program
{
    public static void Main()
    {
" + indentedCode + @"
    }
}";
        }
    }

    private string IndentCode(string code, string indentation)
    {
        if (string.IsNullOrEmpty(code))
            return code;
            
        var lines = code.Split('\n');
        var indentedLines = lines.Select(line => 
            string.IsNullOrWhiteSpace(line) ? line : indentation + line);
        return string.Join("\n", indentedLines);
    }

    private string ExtractMainMethodContent(string fullCode)
    {
        try
        {
            // Simple extraction - find content between Main() { and the last }
            var mainStart = fullCode.IndexOf("public static void Main()");
            if (mainStart == -1) return fullCode; // If we can't find Main, return full code
            
            var openBrace = fullCode.IndexOf('{', mainStart);
            if (openBrace == -1) return fullCode;
            
            // Find the matching closing brace for the Main method
            int braceCount = 0;
            int i = openBrace;
            while (i < fullCode.Length)
            {
                if (fullCode[i] == '{') braceCount++;
                else if (fullCode[i] == '}') braceCount--;
                
                if (braceCount == 0)
                {
                    // Found the closing brace for Main method
                    var mainContent = fullCode.Substring(openBrace + 1, i - openBrace - 1);
                    // Remove indentation for simplified view
                    return RemoveIndentation(mainContent.Trim());
                }
                i++;
            }
            
            return fullCode; // Fallback
        }
        catch
        {
            return fullCode; // Fallback on any error
        }
    }

    private string RemoveIndentation(string code)
    {
        if (string.IsNullOrEmpty(code))
            return code;
            
        var lines = code.Split('\n');
        var unindentedLines = lines.Select(line => 
        {
            // Remove up to 8 leading spaces (or fewer if the line has less)
            if (line.Length >= 8 && line.Substring(0, 8) == "        ")
                return line.Substring(8);
            else if (line.StartsWith("    "))
                return line.Substring(4); // Remove 4 spaces if that's what we have
            else
                return line.TrimStart(); // Just trim any leading whitespace
        });
        return string.Join("\n", unindentedLines);
    }

    protected override void OnInitialized()
    {
        // Initialize the display code based on the toggle state
        // On first load, the displayCode is already set to the unindented sample
        // and sourceCode needs to be built from it
        if (!showFullCode)
        {
            // Build the initial sourceCode from the unindented displayCode
            OnCodeChanged(new ChangeEventArgs { Value = displayCode });
        }
        else
        {
            UpdateDisplayCode();
        }
    }

    private void UpdateDisplayCode()
    {
        if (showFullCode)
        {
            displayCode = sourceCode;
        }
        else
        {
            displayCode = ExtractMainMethodContent(sourceCode);
        }
        StateHasChanged();
    }

    private void OnToggleChanged(ChangeEventArgs e)
    {
        // First, ensure the current displayCode is saved to sourceCode
        OnCodeChanged(new ChangeEventArgs { Value = displayCode });
        
        // Then toggle the view mode
        showFullCode = (bool)(e.Value ?? false);
        
        // Finally, update the display code for the new mode
        UpdateDisplayCode();
    }

    private void LoadSampleCode()
    {
        // Replace the current source code with the sample code
        sourceCode = sampleCode;
        
        // Update the display based on current toggle state
        UpdateDisplayCode();
        StateHasChanged();
    }

    // Accessibility helper methods
    private string GetCompileButtonLabel()
    {
        return isCompiling ? "Currently compiling your C# code, please wait" : "Compile and run your C# code";
    }

    // Keyboard navigation handlers
    private async Task HandleKeyDown(KeyboardEventArgs e, Action action)
    {
        if (e.Key == "Enter" || e.Key == " ")
        {
            action.Invoke();
            await Task.CompletedTask;
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e, Func<Task> asyncAction)
    {
        if (e.Key == "Enter" || e.Key == " ")
        {
            await asyncAction();
        }
    }

    private async Task HandleToggleKeyDown(KeyboardEventArgs e, Action<ChangeEventArgs> toggleAction)
    {
        // Simplified keyboard handler for toggles
        if (e.Key == "Enter" || e.Key == " ")
        {
            StateHasChanged();
            await Task.CompletedTask;
        }
    }

    private async Task HandleEditorKeyDown(KeyboardEventArgs e)
    {
        // Ctrl+Enter to compile and run
        if (e.CtrlKey && e.Key == "Enter")
        {
            await CompileAndRun();
        }
        // Ctrl+L to load sample code
        else if (e.CtrlKey && e.Key == "l")
        {
            LoadSampleCode();
        }
        // Ctrl+K to clear output
        else if (e.CtrlKey && e.Key == "k")
        {
            ClearOutput();
        }
    }

    private Task<CompilationResult> CompileCSharpCode(string code)
    {
        try
        {
            // Extract using statements from user code and put them at the top
            var lines = code.Split('\n');
            var usingStatements = new List<string>();
            var userCodeLines = new List<string>();
            
            bool inUsings = true;
            foreach (var line in lines)
            {
                var trimmedLine = line.Trim();
                if (inUsings && trimmedLine.StartsWith("using "))
                {
                    usingStatements.Add(line);
                }
                else if (inUsings && (string.IsNullOrWhiteSpace(trimmedLine) || trimmedLine.StartsWith("//")))
                {
                    // Allow empty lines and comments in the using section
                    usingStatements.Add(line);
                }
                else
                {
                    inUsings = false;
                    userCodeLines.Add(line);
                }
            }
            
            // Inject a Console replacement class that captures output
            var consoleReplacementCode = @"
public static class Console
{
    private static System.Text.StringBuilder _output = new System.Text.StringBuilder();
    private static System.Collections.Generic.Queue<string> _inputQueue = new System.Collections.Generic.Queue<string>();
    
    public static void WriteLine()
    {
        _output.AppendLine();
    }
    
    public static void WriteLine(string value)
    {
        _output.AppendLine(value ?? """");
    }
    
    public static void WriteLine(char value)
    {
        _output.AppendLine(value.ToString());
    }
    
    public static void WriteLine(object value)
    {
        _output.AppendLine(value?.ToString() ?? """");
    }
    
    public static void WriteLine(int value)
    {
        _output.AppendLine(value.ToString());
    }
    
    public static void WriteLine(long value)
    {
        _output.AppendLine(value.ToString());
    }
    
    public static void WriteLine(float value)
    {
        _output.AppendLine(value.ToString());
    }
    
    public static void WriteLine(double value)
    {
        _output.AppendLine(value.ToString());
    }
    
    public static void WriteLine(decimal value)
    {
        _output.AppendLine(value.ToString());
    }
    
    public static void WriteLine(bool value)
    {
        _output.AppendLine(value.ToString());
    }
    
    public static void Write(string value)
    {
        _output.Append(value ?? """");
    }
    
    public static void Write(char value)
    {
        _output.Append(value.ToString());
    }
    
    public static void Write(object value)
    {
        _output.Append(value?.ToString() ?? """");
    }
    
    public static void Write(int value)
    {
        _output.Append(value.ToString());
    }
    
    public static void Write(long value)
    {
        _output.Append(value.ToString());
    }
    
    public static void Write(float value)
    {
        _output.Append(value.ToString());
    }
    
    public static void Write(double value)
    {
        _output.Append(value.ToString());
    }
    
    public static void Write(decimal value)
    {
        _output.Append(value.ToString());
    }
    
    public static void Write(bool value)
    {
        _output.Append(value.ToString());
    }
    
    public static string ReadLine()
    {
        if (_inputQueue.Count > 0)
        {
            return _inputQueue.Dequeue();
        }
        
        throw new System.InvalidOperationException(""READLINE_INPUT_REQUIRED"");
    }
    
    internal static string GetCapturedOutput()
    {
        return _output.ToString();
    }
    
    internal static void ClearOutput()
    {
        _output.Clear();
        _inputQueue.Clear();
    }
    
    internal static void AddInputLine(string input)
    {
        _inputQueue.Enqueue(input ?? """");
    }
    
    internal static bool HasPendingInput()
    {
        return _inputQueue.Count > 0;
    }
    
    internal static string GetNextInput()
    {
        return _inputQueue.Count > 0 ? _inputQueue.Dequeue() : """";
    }
}
";
            
            // Combine: using statements + console replacement + user code
            var combinedCode = string.Join("\n", usingStatements) + "\n" + consoleReplacementCode + "\n" + string.Join("\n", userCodeLines);
            var syntaxTree = CSharpSyntaxTree.ParseText(combinedCode);
            
            // For WebAssembly, we need to manually build essential references
            var references = new List<MetadataReference>();
            
            AddOutput("Attempting to load references for WebAssembly environment...", "info");
            
            // Method 1: Try Basic.Reference.Assemblies.Net90 with deep API exploration
            try
            {
                var net90Type = typeof(Basic.Reference.Assemblies.Net90);
                AddOutput($"Basic.Reference.Assemblies.Net90 type loaded: {net90Type.FullName}", "info");
                
                // Access the References nested type
                var referencesType = net90Type.GetNestedType("References");
                if (referencesType != null)
                {
                    AddOutput($"Found References nested type: {referencesType.FullName}", "success");
                    
                    // Get ALL members to understand the API structure
                    var allMembers = referencesType.GetMembers(BindingFlags.Public | BindingFlags.Static);
                    AddOutput($"References type has {allMembers.Length} members", "info");
                    
                    // Show all member types and names
                    foreach (var member in allMembers.Take(20))
                    {
                        AddOutput($"  {member.MemberType}: {member.Name} -> {member}", "info");
                    }
                    
                    // Try different approaches to get references
                    // Approach 1: Look for MetadataReference properties
                    var refProperties = referencesType.GetProperties(BindingFlags.Public | BindingFlags.Static)
                        .Where(p => p.PropertyType == typeof(MetadataReference))
                        .ToArray();
                    AddOutput($"Found {refProperties.Length} MetadataReference properties", "info");
                    
                    // Approach 2: Look for IEnumerable<MetadataReference> properties
                    var enumProperties = referencesType.GetProperties(BindingFlags.Public | BindingFlags.Static)
                        .Where(p => typeof(IEnumerable<MetadataReference>).IsAssignableFrom(p.PropertyType))
                        .ToArray();
                    AddOutput($"Found {enumProperties.Length} IEnumerable<MetadataReference> properties", "info");
                    
                    // Approach 3: Look for methods that return MetadataReference or collections
                    var refMethods = referencesType.GetMethods(BindingFlags.Public | BindingFlags.Static)
                        .Where(m => m.ReturnType == typeof(MetadataReference) || 
                                   typeof(IEnumerable<MetadataReference>).IsAssignableFrom(m.ReturnType))
                        .ToArray();
                    AddOutput($"Found {refMethods.Length} methods returning MetadataReference(s)", "info");
                    
                    // Try the enumerable properties first
                    foreach (var prop in enumProperties)
                    {
                        try
                        {
                            var refs = (IEnumerable<MetadataReference>?)prop.GetValue(null);
                            if (refs != null)
                            {
                                var refsArray = refs.ToArray();
                                references.AddRange(refsArray);
                                AddOutput($"Successfully loaded {refsArray.Length} references from {prop.Name}", "success");
                            }
                        }
                        catch (Exception ex)
                        {
                            AddErrorOutput($"Error loading from {prop.Name}: {ex.Message}", "error");
                        }
                    }
                    
                    // Try individual MetadataReference properties
                    foreach (var prop in refProperties)
                    {
                        try
                        {
                            var reference = (MetadataReference?)prop.GetValue(null);
                            if (reference != null)
                            {
                                references.Add(reference);
                                AddOutput($"Successfully loaded: {prop.Name}", "success");
                            }
                        }
                        catch (Exception ex)
                        {
                            AddErrorOutput($"Error loading {prop.Name}: {ex.Message}", "error");
                        }
                    }
                }
                else
                {
                    AddErrorOutput("References nested type not found", "error");
                }
                
                AddOutput($"Total references loaded: {references.Count}", references.Count > 0 ? "success" : "warning");
            }
            catch (Exception ex)
            {
                AddErrorOutput($"Basic.Reference.Assemblies.Net90 failed: {ex.Message}", "error");
                AddErrorOutput($"Exception details: {ex.GetType().Name}", "error");
            }
            
            // Method 2: If no references loaded, show what we're working with
            if (references.Count == 0)
            {
                AddOutput("No references loaded from Basic.Reference.Assemblies", "warning");
                AddOutput("Proceeding with compilation to see specific errors...", "info");
                
                // List the assemblies we have available
                var loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
                AddOutput($"Available assemblies in current domain: {loadedAssemblies.Length}", "info");
                
                foreach (var asm in loadedAssemblies.Take(10))
                {
                    var name = asm.GetName().Name ?? "Unknown";
                    var location = string.IsNullOrEmpty(asm.Location) ? "No location" : asm.Location;
                    AddOutput($"  {name} -> {location}", "info");
                }
            }

            // Attempt compilation with whatever references we have
            var compilation = CSharpCompilation.Create(
                "DynamicAssembly",
                new[] { syntaxTree },
                references,
                new CSharpCompilationOptions(OutputKind.ConsoleApplication));

            using var ms = new MemoryStream();
            var emitResult = compilation.Emit(ms);

            if (emitResult.Success)
            {
                AddOutput("Compilation succeeded!", "success");
                ms.Seek(0, SeekOrigin.Begin);
                var assembly = Assembly.Load(ms.ToArray());
                return Task.FromResult(new CompilationResult { Success = true, Assembly = assembly });
            }
            else
            {
                var errors = emitResult.Diagnostics
                    .Where(d => d.Severity == DiagnosticSeverity.Error)
                    .ToList();
                
                AddErrorOutput($"Compilation failed with {errors.Count} errors", "error");
                
                // Group similar errors and show summary
                var errorGroups = errors.GroupBy(e => e.Id).ToArray();
                AddErrorOutput("Error summary:", "error");
                
                foreach (var group in errorGroups.Take(5)) // Show top 5 error types
                {
                    var firstError = group.First();
                    var count = group.Count();
                    AddErrorOutput($"  {group.Key}: {firstError.GetMessage()} ({count} occurrences)", "error");
                }
                
                if (errorGroups.Length > 5)
                {
                    AddErrorOutput($"  ... and {errorGroups.Length - 5} other error types", "error");
                }
                
                return Task.FromResult(new CompilationResult 
                { 
                    Success = false, 
                    Errors = errors
                });
            }
        }
        catch (Exception ex)
        {
            AddErrorOutput($"Compilation exception: {ex.Message}", "error");
            AddErrorOutput($"Exception type: {ex.GetType().Name}", "error");
            if (ex.InnerException != null)
            {
                AddErrorOutput($"Inner exception: {ex.InnerException.Message}", "error");
            }
            
            return Task.FromResult(new CompilationResult 
            { 
                Success = false, 
                Errors = new List<Diagnostic>()
            });
        }
    }

    private byte[]? GetAssemblyBytes(Assembly assembly)
    {
        try
        {
            // In WebAssembly, we need to extract assembly bytes differently
            // Try multiple approaches to get the assembly data
            
            // Method 1: Try to use the location if available
            if (!string.IsNullOrEmpty(assembly.Location))
            {
                return File.ReadAllBytes(assembly.Location);
            }
            
            // Method 2: Try to get from memory (this might work in some WebAssembly scenarios)
            return null;
        }
        catch (Exception ex)
        {
            AddErrorOutput($"GetAssemblyBytes error for {assembly.GetName().Name}: {ex.Message}", "error");
            return null;
        }
    }

    private async Task<string> ExecuteAssembly(Assembly assembly)
    {
        try
        {
            // First, clear any previous output from our custom Console
            var consoleType = assembly.GetType("Console");
            if (consoleType != null)
            {
                var clearMethod = consoleType.GetMethod("ClearOutput", BindingFlags.Static | BindingFlags.NonPublic);
                clearMethod?.Invoke(null, null);
            }
            
            // Find the Main method
            var entryPoint = assembly.EntryPoint;
            MethodInfo? mainMethod = null;
            
            if (entryPoint != null)
            {
                mainMethod = entryPoint;
            }
            else
            {
                // Fallback: Look for Program.Main method manually
                var programType = assembly.GetType("Program");
                if (programType != null)
                {
                    // Try Main() first
                    mainMethod = programType.GetMethod("Main", BindingFlags.Static | BindingFlags.Public, null, Type.EmptyTypes, null);
                    if (mainMethod == null)
                    {
                        // Try Main(string[])
                        mainMethod = programType.GetMethod("Main", BindingFlags.Static | BindingFlags.Public, null, new[] { typeof(string[]) }, null);
                    }
                }
            }
            
            if (mainMethod == null)
            {
                return "Error: No suitable Main method found";
            }
            
            // Execute the program with interactive input support
            return await ExecuteWithInteractiveInput(assembly, mainMethod, consoleType);
        }
        catch (Exception ex)
        {
            AddErrorOutput($"Execution error: {ex.GetType().Name}: {ex.Message}", "error");
            if (ex.StackTrace != null)
            {
                AddErrorOutput($"Stack trace: {ex.StackTrace}", "error");
            }
            return $"Execution error: {ex.Message}";
        }
    }

    private async Task<string> ExecuteWithInteractiveInput(Assembly assembly, MethodInfo mainMethod, Type? consoleType)
    {
        try
        {
            var allInputs = new List<string>();
            var finalOutput = "";
            
            while (true)
            {
                // Clear the console for this execution attempt
                if (consoleType != null)
                {
                    var clearMethod = consoleType.GetMethod("ClearOutput", BindingFlags.Static | BindingFlags.NonPublic);
                    clearMethod?.Invoke(null, null);
                    
                    // Add all previously collected inputs
                    var addInputMethod = consoleType.GetMethod("AddInputLine", BindingFlags.Static | BindingFlags.NonPublic);
                    foreach (var input in allInputs)
                    {
                        addInputMethod?.Invoke(null, new object[] { input });
                    }
                }
                
                var parameters = mainMethod.GetParameters();
                object?[] args = parameters.Length == 0 ? null : new object[] { new string[0] };
                
                try
                {
                    // Try to execute the program with current inputs
                    mainMethod.Invoke(null, args);
                    
                    // If we get here, the program completed successfully
                    if (consoleType != null)
                    {
                        var getOutputMethod = consoleType.GetMethod("GetCapturedOutput", BindingFlags.Static | BindingFlags.NonPublic);
                        if (getOutputMethod != null)
                        {
                            finalOutput = getOutputMethod.Invoke(null, null) as string ?? "";
                        }
                    }
                    break; // Success!
                }
                catch (TargetInvocationException ex) when (ex.InnerException?.Message == "READLINE_INPUT_REQUIRED")
                {
                    // The program needs more input
                    // Get the current output to show what has been produced so far
                    if (consoleType != null)
                    {
                        var getOutputMethod = consoleType.GetMethod("GetCapturedOutput", BindingFlags.Static | BindingFlags.NonPublic);
                        if (getOutputMethod != null)
                        {
                            var currentOutput = getOutputMethod.Invoke(null, null) as string ?? "";
                            
                            // Display the current output (this includes any prompt text)
                            AddUserOutput(currentOutput);
                            StateHasChanged();
                            await ScrollToBottom();
                        }
                    }
                    
                    // Get input from user
                    var userInput = await JSRuntime.InvokeAsync<string>("promptForInput", "");
                    
                    // Add this input to our collection
                    allInputs.Add(userInput);
                    
                    // Show the user input in the console
                    AddUserOutput(userInput + "\n");
                    StateHasChanged();
                    await ScrollToBottom();
                    
                    // Continue the loop to restart execution with all inputs
                    continue;
                }
            }
            
            return finalOutput;
        }
        catch (TargetInvocationException ex) when (ex.InnerException?.Message == "READLINE_INPUT_REQUIRED")
        {
            return "Program execution stopped - more input required than expected.";
        }
        catch (TargetInvocationException ex)
        {
            var innerEx = ex.InnerException ?? ex;
            AddErrorOutput($"Execution error: {innerEx.GetType().Name}: {innerEx.Message}", "error");
            return $"Execution error: {innerEx.Message}";
        }
    }

    private async Task<string> ExecuteAssemblyInteractively(Assembly assembly, MethodInfo mainMethod)
    {
        // This method is no longer used - replaced by ExecuteWithInteractiveInput
        return "Interactive execution completed";
    }

    private class CompilationResult
    {
        public bool Success { get; set; }
        public Assembly? Assembly { get; set; }
        public List<Diagnostic> Errors { get; set; } = new();
    }
}